# Learnings: testing

- [Story 1.1] When extracting pattern libraries from a monolith, not all \"regex\" table rows will have actual regex — some patterns like \"Names in test data\" use descriptive text instead of a regex. The test definition's regex-based counting (`^\\| .+ \\| `.+` \\|`) will miss these rows. Validate with both the strict backtick test AND a category-scoped row count to ensure no patterns are lost. Split the content by category headers and count data rows within each section for accurate results.
- [Story 1.1] When extracting pattern libraries from a monolith, not all "regex" table rows will have actual regex — some patterns like "Names in test data" use descriptive text instead of a regex. The test definition's regex-based counting (`^\| .+ \| `.+` \|`) will miss these rows. Validate with both the strict backtick test AND a category-scoped row count to ensure no patterns are lost. Split the content by category headers and count data rows within each section for accurate results.
- [Story 2.5] Phase 4 is unique among the extracted phases because it uses no shared pattern libraries (unlike Phases 1-2 which reference patterns/secrets.md and patterns/pii.md). When mentioning this fact in the extracted file for clarity (\"Phase 4 does not reference patterns/secrets.md\"), be careful that validation tests checking for absence of pattern references use the right grep pattern (e.g., `Read.*patterns/` to check for operational usage, not just any mention). Also, zsh shells interpret `!` inside command substitutions differently from bash — use explicit exit code checks (`$?`) instead of `! grep -q` for portable test scripts.
- [Story 2.5] Phase 4 is unique among the extracted phases because it uses no shared pattern libraries (unlike Phases 1-2 which reference patterns/secrets.md and patterns/pii.md). When mentioning this fact in the extracted file for clarity ("Phase 4 does not reference patterns/secrets.md"), be careful that validation tests checking for absence of pattern references use the right grep pattern (e.g., `Read.*patterns/` to check for operational usage, not just any mention). Also, zsh shells interpret `!` inside command substitutions differently from bash — use explicit exit code checks (`$?`) instead of `! grep -q` for portable test scripts.
- [Story 2.7] Phase 6 was a clean extraction with no bug fixes needed — the most straightforward kind of phase extraction. For phases that don't reference shared pattern libraries (secrets.md, pii.md), the self-containment test is simpler. The key structural elements to verify in every extracted phase file are: header block (phase number, name, inputs, outputs), all step numbers present, finding ID format with phase-specific prefix, user gate with all four options referencing the next phase, and state update documentation. For content-heavy phases with verbatim templates (YAML frontmatter, CI workflow variants, .gitignore tables), count the specific entries against the spec rather than relying on general pattern matching.
- [Story 2.7] Phase 6 was a clean extraction with no bug fixes needed — the most straightforward kind of phase extraction. For phases that don't reference shared pattern libraries (secrets.md, pii.md), the self-containment test is simpler. The key structural elements to verify in every extracted phase file are: header block (phase number, name, inputs, outputs), all step numbers present, finding ID format with phase-specific prefix, user gate with all four options referencing the next phase, and state update documentation. For content-heavy phases with verbatim templates (YAML frontmatter, CI workflow variants, .gitignore tables), count the specific entries against the spec rather than relying on general pattern matching.
- [Story 2.9] When extracting a phase that has a mid-phase user gate splitting it into two sub-agent calls, clearly mark each step with blockquote annotations (e.g., `> **Sub-Agent Call 1**`, `> **Orchestrator responsibility**`) so the orchestrator knows exactly which steps to dispatch to which sub-agent. This is more maintainable than relying on prose paragraphs that describe the split — inline markers at each step heading make boundaries unambiguous.
- [Story 2.9] When extracting a phase that has a mid-phase user gate splitting it into two sub-agent calls, clearly mark each step with blockquote annotations (e.g., `> **Sub-Agent Call 1**`, `> **Orchestrator responsibility**`) so the orchestrator knows exactly which steps to dispatch to which sub-agent. This is more maintainable than relying on prose paragraphs that describe the split — inline markers at each step heading make boundaries unambiguous.
