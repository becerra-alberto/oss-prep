# Learnings: framework

- [Story 2.6] When extracting a phase that has a bug fix involving cross-phase state dependencies (e.g., license_choice set in Phase 3, consumed in Phase 5), clearly document two code paths: a \"primary path\" that reads state and a \"fallback path\" that preserves the original interactive behavior. The fallback must note which component (orchestrator vs sub-agent) handles the interaction, since sub-agents cannot interact with users directly. This pattern — primary/fallback with interaction-point documentation — makes the orchestrator's dispatch logic straightforward while keeping the phase file self-contained.
- [Story 2.6] When extracting a phase that has a bug fix involving cross-phase state dependencies (e.g., license_choice set in Phase 3, consumed in Phase 5), clearly document two code paths: a "primary path" that reads state and a "fallback path" that preserves the original interactive behavior. The fallback must note which component (orchestrator vs sub-agent) handles the interaction, since sub-agents cannot interact with users directly. This pattern — primary/fallback with interaction-point documentation — makes the orchestrator's dispatch logic straightforward while keeping the phase file self-contained.
- [Story 3.1] For a thin orchestrator replacing a monolith, the key structural sections are: (1) frontmatter preserved verbatim, (2) startup validation with specific error messages, (3) state management with atomic writes and post-completion ordering, (4) resume support, (5) phase sequencing loop with sub-agent dispatch template, (6) special-case phase patterns (Phase 8 two-dispatch, Phase 3/5 license pre-checks), (7) commit strategy with scoped staging, (8) failure handling with retry-then-fallback, and (9) preserved verbatim interaction model and grounding requirement sections. The result: 206 lines vs 3,484 — a 94% reduction while preserving all behavioral contracts.
- [Story 3.1] For a thin orchestrator replacing a monolith, the key structural sections are: (1) frontmatter preserved verbatim, (2) startup validation with specific error messages, (3) state management with atomic writes and post-completion ordering, (4) resume support, (5) phase sequencing loop with sub-agent dispatch template, (6) special-case phase patterns (Phase 8 two-dispatch, Phase 3/5 license pre-checks), (7) commit strategy with scoped staging, (8) failure handling with retry-then-fallback, and (9) preserved verbatim interaction model and grounding requirement sections. The result: 206 lines vs 3,484 — a 94% reduction while preserving all behavioral contracts.
