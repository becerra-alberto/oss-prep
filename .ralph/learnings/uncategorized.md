# Learnings: uncategorized

- [Story 2.1] When extracting a phase file from a monolith, the key structural decisions are: (1) the header block format with Phase/Name/Inputs/Outputs metadata, (2) keeping all detection heuristics inline and verbatim rather than summarizing them, (3) documenting the user gate separately from the steps so the orchestrator knows what to present, and (4) including a \"Finding Format\" section even when the phase doesn't produce security findings — Phase 0's \"findings\" are anomalies, not security issues, so documenting that distinction explicitly prevents confusion in the orchestrator.
- [Story 2.1] When extracting a phase file from a monolith, the key structural decisions are: (1) the header block format with Phase/Name/Inputs/Outputs metadata, (2) keeping all detection heuristics inline and verbatim rather than summarizing them, (3) documenting the user gate separately from the steps so the orchestrator knows what to present, and (4) including a "Finding Format" section even when the phase doesn't produce security findings — Phase 0's "findings" are anomalies, not security issues, so documenting that distinction explicitly prevents confusion in the orchestrator.
- [Story 2.9] When a phase file needs to duplicate content from another phase (like the PII allowlist in Phase 8's post-flatten verification), document WHY the duplication exists with an explicit header comment (e.g., \"duplicated from Phase 2 for sub-agent self-containment\"). This prevents future maintainers from removing the \"duplication\" as a cleanup, which would break the sub-agent's ability to run independently.
- [Story 2.9] When a phase file needs to duplicate content from another phase (like the PII allowlist in Phase 8's post-flatten verification), document WHY the duplication exists with an explicit header comment (e.g., "duplicated from Phase 2 for sub-agent self-containment"). This prevents future maintainers from removing the "duplication" as a cleanup, which would break the sub-agent's ability to run independently.
- [Story 3.1] When prerequisite stories commit files via worktree branches that get merged, files can be lost if the merge had path mismatches (e.g., files committed relative to a subdirectory CWD rather than the git root). Always verify prerequisite file existence at HEAD before starting a capstone story, and know how to recover from git object history using `git show {commit}:{path}`. In this case, `phases/05-documentation.md` was committed in story 2.6 at the path `phases/05-documentation.md` (relative to the oss-prep skill dir, not the repo root), which caused it to not appear at HEAD in the main tree. Recovery was straightforward: `git show {commit}:phases/05-documentation.md > phases/05-documentation.md`.
- [Story 3.1] When prerequisite stories commit files via worktree branches that get merged, files can be lost if the merge had path mismatches (e.g., files committed relative to a subdirectory CWD rather than the git root). Always verify prerequisite file existence at HEAD before starting a capstone story, and know how to recover from git object history using `git show {commit}:{path}`. In this case, `phases/05-documentation.md` was committed in story 2.6 at the path `phases/05-documentation.md` (relative to the oss-prep skill dir, not the repo root), which caused it to not appear at HEAD in the main tree. Recovery was straightforward: `git show {commit}:phases/05-documentation.md > phases/05-documentation.md`.
