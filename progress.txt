[LEARN] When extracting pattern libraries from a monolith, not all \"regex\" table rows will have actual regex — some patterns like \"Names in test data\" use descriptive text instead of a regex. The test definition's regex-based counting (`^\\| .+ \\| `.+` \\|`) will miss these rows. Validate with both the strict backtick test AND a category-scoped row count to ensure no patterns are lost. Split the content by category headers and count data rows within each section for accurate results.
[LEARN] When extracting pattern libraries from a monolith, not all "regex" table rows will have actual regex — some patterns like "Names in test data" use descriptive text instead of a regex. The test definition's regex-based counting (`^\| .+ \| `.+` \|`) will miss these rows. Validate with both the strict backtick test AND a category-scoped row count to ensure no patterns are lost. Split the content by category headers and count data rows within each section for accurate results.
[DONE] Story 1.1 - Create shared pattern libraries and state schema - Fri 13 Feb 2026 00:12:16 CST
[DONE] Story 2.1 - Extract Phase 0 — Reconnaissance - Fri 13 Feb 2026 00:26:14 CST
[LEARN] When extracting a phase file from a monolith, the key structural decisions are: (1) the header block format with Phase/Name/Inputs/Outputs metadata, (2) keeping all detection heuristics inline and verbatim rather than summarizing them, (3) documenting the user gate separately from the steps so the orchestrator knows what to present, and (4) including a \"Finding Format\" section even when the phase doesn't produce security findings — Phase 0's \"findings\" are anomalies, not security issues, so documenting that distinction explicitly prevents confusion in the orchestrator.
[LEARN] When extracting a phase file from a monolith, the key structural decisions are: (1) the header block format with Phase/Name/Inputs/Outputs metadata, (2) keeping all detection heuristics inline and verbatim rather than summarizing them, (3) documenting the user gate separately from the steps so the orchestrator knows what to present, and (4) including a "Finding Format" section even when the phase doesn't produce security findings — Phase 0's "findings" are anomalies, not security issues, so documenting that distinction explicitly prevents confusion in the orchestrator.
[DONE] Story 2.2 - Extract Phase 1 — Secrets Audit - Fri 13 Feb 2026 00:26:15 CST
[LEARN] When extracting a phase from a monolith, the key changes are surgical: (1) replace inline pattern content with a reference to the shared library file, (2) update cross-references in sub-agent dispatch instructions (e.g., \"copy the patterns section below\" → \"read patterns/secrets.md\"), and (3) add a structured header block (Phase, Name, Inputs, Outputs) plus an orchestrator note on the user gate. The bulk of the content (steps, classification rules, remediation types, formats) should be extracted verbatim to avoid introducing subtle differences between the monolith and the decomposed version.
[LEARN] When extracting a phase from a monolith, the key changes are surgical: (1) replace inline pattern content with a reference to the shared library file, (2) update cross-references in sub-agent dispatch instructions (e.g., "copy the patterns section below" → "read patterns/secrets.md"), and (3) add a structured header block (Phase, Name, Inputs, Outputs) plus an orchestrator note on the user gate. The bulk of the content (steps, classification rules, remediation types, formats) should be extracted verbatim to avoid introducing subtle differences between the monolith and the decomposed version.
[DONE] Story 2.3 - Extract Phase 2 — PII Audit - Fri 13 Feb 2026 00:26:15 CST
[LEARN] When extracting a phase that has both shared pattern content (Step 2.2 regex tables) and phase-specific content (Step 2.3 allowlist), the key transformation is surgical: replace the shared content with a \"Read patterns/X.md\" directive while keeping the phase-specific content verbatim inline. Also update sub-agent dispatch instructions to reference the patterns file instead of \"copy the patterns section below\". The Step 2.2 section should become a summary listing the 8 categories rather than being deleted entirely — this helps readers understand what the patterns file contains without needing to open it.
[LEARN] When extracting a phase that has both shared pattern content (Step 2.2 regex tables) and phase-specific content (Step 2.3 allowlist), the key transformation is surgical: replace the shared content with a "Read patterns/X.md" directive while keeping the phase-specific content verbatim inline. Also update sub-agent dispatch instructions to reference the patterns file instead of "copy the patterns section below". The Step 2.2 section should become a summary listing the 8 categories rather than being deleted entirely — this helps readers understand what the patterns file contains without needing to open it.
[DONE] Story 2.4 - Extract Phase 3 — Dependencies with license fix - Fri 13 Feb 2026 00:26:15 CST
[LEARN] When extracting a phase that has a design bug requiring orchestrator-side pre-checks (like the license selection preamble in Phase 3), clearly mark the boundary between orchestrator and sub-agent responsibilities using an architectural note at the top of the pre-check step. The DD-4 constraint (sub-agents cannot interact with users) means any user-interactive steps must be documented as orchestrator-side work that passes results as inputs to the sub-agent. This pattern — orchestrator resolves interactive input, then passes it as a typed input to the sub-agent — will recur in any phase that needs user decisions before sub-agent execution.
[LEARN] When extracting a phase that has a design bug requiring orchestrator-side pre-checks (like the license selection preamble in Phase 3), clearly mark the boundary between orchestrator and sub-agent responsibilities using an architectural note at the top of the pre-check step. The DD-4 constraint (sub-agents cannot interact with users) means any user-interactive steps must be documented as orchestrator-side work that passes results as inputs to the sub-agent. This pattern — orchestrator resolves interactive input, then passes it as a typed input to the sub-agent — will recur in any phase that needs user decisions before sub-agent execution.
[DONE] Story 2.5 - Extract Phase 4 — Code Quality - Fri 13 Feb 2026 00:26:15 CST
[LEARN] Phase 4 is unique among the extracted phases because it uses no shared pattern libraries (unlike Phases 1-2 which reference patterns/secrets.md and patterns/pii.md). When mentioning this fact in the extracted file for clarity (\"Phase 4 does not reference patterns/secrets.md\"), be careful that validation tests checking for absence of pattern references use the right grep pattern (e.g., `Read.*patterns/` to check for operational usage, not just any mention). Also, zsh shells interpret `!` inside command substitutions differently from bash — use explicit exit code checks (`$?`) instead of `! grep -q` for portable test scripts.
[LEARN] Phase 4 is unique among the extracted phases because it uses no shared pattern libraries (unlike Phases 1-2 which reference patterns/secrets.md and patterns/pii.md). When mentioning this fact in the extracted file for clarity ("Phase 4 does not reference patterns/secrets.md"), be careful that validation tests checking for absence of pattern references use the right grep pattern (e.g., `Read.*patterns/` to check for operational usage, not just any mention). Also, zsh shells interpret `!` inside command substitutions differently from bash — use explicit exit code checks (`$?`) instead of `! grep -q` for portable test scripts.
[DONE] Story 2.6 - Extract Phase 5 — Documentation with license adjustment - Fri 13 Feb 2026 00:26:15 CST
[LEARN] When extracting a phase that has a bug fix involving cross-phase state dependencies (e.g., license_choice set in Phase 3, consumed in Phase 5), clearly document two code paths: a \"primary path\" that reads state and a \"fallback path\" that preserves the original interactive behavior. The fallback must note which component (orchestrator vs sub-agent) handles the interaction, since sub-agents cannot interact with users directly. This pattern — primary/fallback with interaction-point documentation — makes the orchestrator's dispatch logic straightforward while keeping the phase file self-contained.
[LEARN] When extracting a phase that has a bug fix involving cross-phase state dependencies (e.g., license_choice set in Phase 3, consumed in Phase 5), clearly document two code paths: a "primary path" that reads state and a "fallback path" that preserves the original interactive behavior. The fallback must note which component (orchestrator vs sub-agent) handles the interaction, since sub-agents cannot interact with users directly. This pattern — primary/fallback with interaction-point documentation — makes the orchestrator's dispatch logic straightforward while keeping the phase file self-contained.
[DONE] Story 2.7 - Extract Phase 6 — GitHub Setup - Fri 13 Feb 2026 00:26:15 CST
[LEARN] Phase 6 was a clean extraction with no bug fixes needed — the most straightforward kind of phase extraction. For phases that don't reference shared pattern libraries (secrets.md, pii.md), the self-containment test is simpler. The key structural elements to verify in every extracted phase file are: header block (phase number, name, inputs, outputs), all step numbers present, finding ID format with phase-specific prefix, user gate with all four options referencing the next phase, and state update documentation. For content-heavy phases with verbatim templates (YAML frontmatter, CI workflow variants, .gitignore tables), count the specific entries against the spec rather than relying on general pattern matching.
[LEARN] Phase 6 was a clean extraction with no bug fixes needed — the most straightforward kind of phase extraction. For phases that don't reference shared pattern libraries (secrets.md, pii.md), the self-containment test is simpler. The key structural elements to verify in every extracted phase file are: header block (phase number, name, inputs, outputs), all step numbers present, finding ID format with phase-specific prefix, user gate with all four options referencing the next phase, and state update documentation. For content-heavy phases with verbatim templates (YAML frontmatter, CI workflow variants, .gitignore tables), count the specific entries against the spec rather than relying on general pattern matching.
[DONE] Story 2.8 - Extract Phase 7 — Naming and Identity - Fri 13 Feb 2026 00:26:16 CST
[LEARN] Phase 7 is the cleanest extraction of the series — no shared pattern library references, no bug fixes needed, no sub-agent parallelization. When a phase is purely self-contained with inline patterns (identity leak regexes, SDK tables), the extraction is a straightforward copy-and-reformat with the header block/I/O/gate additions. The key structural difference from phases that reference shared patterns (like Phase 1 referencing patterns/secrets.md) is that self-contained phases are simpler to validate — just confirm all tables and regex patterns were preserved verbatim.
[LEARN] Phase 7 is the cleanest extraction of the series — no shared pattern library references, no bug fixes needed, no sub-agent parallelization. When a phase is purely self-contained with inline patterns (identity leak regexes, SDK tables), the extraction is a straightforward copy-and-reformat with the header block/I/O/gate additions. The key structural difference from phases that reference shared patterns (like Phase 1 referencing patterns/secrets.md) is that self-contained phases are simpler to validate — just confirm all tables and regex patterns were preserved verbatim.
[DONE] Story 2.9 - Extract Phase 8 — History Flatten with safety hardening - Fri 13 Feb 2026 00:26:16 CST
[LEARN] When extracting a phase that has a mid-phase user gate splitting it into two sub-agent calls, clearly mark each step with blockquote annotations (e.g., `> **Sub-Agent Call 1**`, `> **Orchestrator responsibility**`) so the orchestrator knows exactly which steps to dispatch to which sub-agent. This is more maintainable than relying on prose paragraphs that describe the split — inline markers at each step heading make boundaries unambiguous.
[LEARN] When a phase file needs to duplicate content from another phase (like the PII allowlist in Phase 8's post-flatten verification), document WHY the duplication exists with an explicit header comment (e.g., \"duplicated from Phase 2 for sub-agent self-containment\"). This prevents future maintainers from removing the \"duplication\" as a cleanup, which would break the sub-agent's ability to run independently.
[LEARN] When extracting a phase that has a mid-phase user gate splitting it into two sub-agent calls, clearly mark each step with blockquote annotations (e.g., `> **Sub-Agent Call 1**`, `> **Orchestrator responsibility**`) so the orchestrator knows exactly which steps to dispatch to which sub-agent. This is more maintainable than relying on prose paragraphs that describe the split — inline markers at each step heading make boundaries unambiguous.
[LEARN] When a phase file needs to duplicate content from another phase (like the PII allowlist in Phase 8's post-flatten verification), document WHY the duplication exists with an explicit header comment (e.g., "duplicated from Phase 2 for sub-agent self-containment"). This prevents future maintainers from removing the "duplication" as a cleanup, which would break the sub-agent's ability to run independently.
[DONE] Story 2.10 - Extract Phase 9 — Final Report - Fri 13 Feb 2026 00:26:16 CST
[LEARN] Phase 9 is unique among all extraction stories because it produces NO new findings — it's purely a synthesis/aggregation phase. The extraction pattern still works well: header block with I/O, steps, finding format, user gate. But for aggregation phases, the \"Finding Format\" section should document how existing findings are classified (status labels) rather than how new findings are generated. The orchestrator note pattern (sub-agent returns data, orchestrator presents to user) is important to preserve for phases that have user-facing presentation variants.
[LEARN] Phase 9 is unique among all extraction stories because it produces NO new findings — it's purely a synthesis/aggregation phase. The extraction pattern still works well: header block with I/O, steps, finding format, user gate. But for aggregation phases, the "Finding Format" section should document how existing findings are classified (status labels) rather than how new findings are generated. The orchestrator note pattern (sub-agent returns data, orchestrator presents to user) is important to preserve for phases that have user-facing presentation variants.
[LEARN] When prerequisite stories commit files via worktree branches that get merged, files can be lost if the merge had path mismatches (e.g., files committed relative to a subdirectory CWD rather than the git root). Always verify prerequisite file existence at HEAD before starting a capstone story, and know how to recover from git object history using `git show {commit}:{path}`. In this case, `phases/05-documentation.md` was committed in story 2.6 at the path `phases/05-documentation.md` (relative to the oss-prep skill dir, not the repo root), which caused it to not appear at HEAD in the main tree. Recovery was straightforward: `git show {commit}:phases/05-documentation.md > phases/05-documentation.md`.
[LEARN] For a thin orchestrator replacing a monolith, the key structural sections are: (1) frontmatter preserved verbatim, (2) startup validation with specific error messages, (3) state management with atomic writes and post-completion ordering, (4) resume support, (5) phase sequencing loop with sub-agent dispatch template, (6) special-case phase patterns (Phase 8 two-dispatch, Phase 3/5 license pre-checks), (7) commit strategy with scoped staging, (8) failure handling with retry-then-fallback, and (9) preserved verbatim interaction model and grounding requirement sections. The result: 206 lines vs 3,484 — a 94% reduction while preserving all behavioral contracts.
[LEARN] When prerequisite stories commit files via worktree branches that get merged, files can be lost if the merge had path mismatches (e.g., files committed relative to a subdirectory CWD rather than the git root). Always verify prerequisite file existence at HEAD before starting a capstone story, and know how to recover from git object history using `git show {commit}:{path}`. In this case, `phases/05-documentation.md` was committed in story 2.6 at the path `phases/05-documentation.md` (relative to the oss-prep skill dir, not the repo root), which caused it to not appear at HEAD in the main tree. Recovery was straightforward: `git show {commit}:phases/05-documentation.md > phases/05-documentation.md`.
[LEARN] For a thin orchestrator replacing a monolith, the key structural sections are: (1) frontmatter preserved verbatim, (2) startup validation with specific error messages, (3) state management with atomic writes and post-completion ordering, (4) resume support, (5) phase sequencing loop with sub-agent dispatch template, (6) special-case phase patterns (Phase 8 two-dispatch, Phase 3/5 license pre-checks), (7) commit strategy with scoped staging, (8) failure handling with retry-then-fallback, and (9) preserved verbatim interaction model and grounding requirement sections. The result: 206 lines vs 3,484 — a 94% reduction while preserving all behavioral contracts.
[DONE] Story 3.1 - Replace SKILL.md with thin orchestrator - Fri 13 Feb 2026 00:30:22 CST
